{"2407.20143": {"publish_time": "2024-07-29", "title": "ByteCheckpoint: A Unified Checkpointing System for LLM Development", "paper_summary": "The development of real-world Large Language Models (LLMs) necessitates\ncheckpointing of training states in persistent storage to mitigate potential\nsoftware and hardware failures, as well as to facilitate checkpoint\ntransferring within the training pipeline and across various tasks. Due to the\nimmense size of LLMs, saving and loading checkpoints often incur intolerable\nminute-level stalls, significantly diminishing training efficiency. Besides,\nwhen transferring checkpoints across tasks, checkpoint resharding, defined as\nloading checkpoints into parallel configurations differing from those used for\nsaving, is often required according to the characteristics and resource quota\nof specific tasks. Previous checkpointing systems [16,3,33,6] assume consistent\nparallel configurations, failing to address the complexities of checkpoint\ntransformation during resharding. Furthermore, in the industry platform,\ndevelopers create checkpoints from different training frameworks[23,36,21,11],\neach with its own unique storage and I/O logic. This diversity complicates the\nimplementation of unified checkpoint management and optimization. To address\nthese challenges, we introduce ByteCheckpoint, a PyTorch-native multi-framework\nLLM checkpointing system that supports automatic online checkpoint resharding.\nByteCheckpoint employs a data/metadata disaggregated storage architecture,\ndecoupling checkpoint storage from the adopted parallelism strategies and\ntraining frameworks. We design an efficient asynchronous tensor merging\ntechnique to settle the irregular tensor sharding problem and propose several\nI/O performance optimizations to significantly enhance the efficiency of\ncheckpoint saving and loading. Experimental results demonstrate\nByteCheckpoint's substantial advantages in reducing checkpoint saving (by up to\n529.22X) and loading (by up to 3.51X) costs, compared to baseline methods.", "paper_summary_zh": "<paragraph>\u7531\u65bc\u8edf\u9ad4\u548c\u786c\u9ad4\u6545\u969c\u7684\u6f5b\u5728\u98a8\u96aa\uff0c\u4ee5\u53ca\u70ba\u4e86\u5728\u8a13\u7df4\u6d41\u7a0b\u548c\u5404\u7a2e\u4efb\u52d9\u4e2d\u4fc3\u9032\u6aa2\u67e5\u9ede\u8f49\u79fb\uff0c\u73fe\u5be6\u4e16\u754c\u7684\u5927\u578b\u8a9e\u8a00\u6a21\u578b (LLM) \u7684\u958b\u767c\u9700\u8981\u5c07\u8a13\u7df4\u72c0\u614b\u6aa2\u67e5\u9ede\u5132\u5b58\u5728\u6c38\u4e45\u5132\u5b58\u88dd\u7f6e\u4e2d\u4ee5\u6e1b\u8f15\u98a8\u96aa\u3002\u7531\u65bc LLM \u7684\u898f\u6a21\u9f90\u5927\uff0c\u5132\u5b58\u548c\u8f09\u5165\u6aa2\u67e5\u9ede\u901a\u5e38\u6703\u9020\u6210\u7121\u6cd5\u5fcd\u53d7\u7684\u5206\u9418\u7d1a\u505c\u6eef\uff0c\u5927\u5e45\u964d\u4f4e\u8a13\u7df4\u6548\u7387\u3002\u6b64\u5916\uff0c\u5728\u4efb\u52d9\u9593\u8f49\u79fb\u6aa2\u67e5\u9ede\u6642\uff0c\u901a\u5e38\u9700\u8981\u6839\u64da\u7279\u5b9a\u4efb\u52d9\u7684\u7279\u5fb5\u548c\u8cc7\u6e90\u914d\u984d\uff0c\u5c07\u6aa2\u67e5\u9ede\u91cd\u65b0\u5206\u7247\uff0c\u9019\u5b9a\u7fa9\u70ba\u5c07\u6aa2\u67e5\u9ede\u8f09\u5165\u8207\u5132\u5b58\u6642\u4e0d\u540c\u7684\u5e73\u884c\u7d44\u614b\u3002\u5148\u524d\u7684\u6aa2\u67e5\u9ede\u7cfb\u7d71 [16,3,33,6] \u5047\u8a2d\u4e00\u81f4\u7684\u5e73\u884c\u7d44\u614b\uff0c\u7121\u6cd5\u89e3\u6c7a\u91cd\u65b0\u5206\u7247\u671f\u9593\u6aa2\u67e5\u9ede\u8f49\u63db\u7684\u8907\u96dc\u6027\u3002\u6b64\u5916\uff0c\u5728\u7522\u696d\u5e73\u53f0\u4e2d\uff0c\u958b\u767c\u4eba\u54e1\u6703\u5f9e\u4e0d\u540c\u7684\u8a13\u7df4\u67b6\u69cb [23,36,21,11] \u5efa\u7acb\u6aa2\u67e5\u9ede\uff0c\u6bcf\u500b\u67b6\u69cb\u90fd\u6709\u81ea\u5df1\u7368\u7279\u7684\u5132\u5b58\u548c I/O \u908f\u8f2f\u3002\u9019\u7a2e\u591a\u6a23\u6027\u8b93\u7d71\u4e00\u7684\u6aa2\u67e5\u9ede\u7ba1\u7406\u548c\u6700\u4f73\u5316\u7684\u5be6\u4f5c\u8b8a\u5f97\u8907\u96dc\u3002\u70ba\u4e86\u61c9\u5c0d\u9019\u4e9b\u6311\u6230\uff0c\u6211\u5011\u5f15\u5165\u4e86 ByteCheckpoint\uff0c\u4e00\u500b PyTorch \u539f\u751f\u7684\u591a\u67b6\u69cb LLM \u6aa2\u67e5\u9ede\u7cfb\u7d71\uff0c\u5b83\u652f\u63f4\u81ea\u52d5\u7dda\u4e0a\u6aa2\u67e5\u9ede\u91cd\u65b0\u5206\u7247\u3002ByteCheckpoint \u4f7f\u7528\u8cc7\u6599/\u5143\u8cc7\u6599\u5206\u96e2\u5132\u5b58\u67b6\u69cb\uff0c\u5c07\u6aa2\u67e5\u9ede\u5132\u5b58\u8207\u63a1\u7528\u7684\u5e73\u884c\u8655\u7406\u7b56\u7565\u548c\u8a13\u7df4\u67b6\u69cb\u812b\u9264\u3002\u6211\u5011\u8a2d\u8a08\u4e86\u4e00\u7a2e\u9ad8\u6548\u7684\u975e\u540c\u6b65\u5f35\u91cf\u5408\u4f75\u6280\u8853\u4f86\u89e3\u6c7a\u4e0d\u898f\u5247\u5f35\u91cf\u5206\u7247\u554f\u984c\uff0c\u4e26\u63d0\u51fa\u591a\u9805 I/O \u6548\u80fd\u6700\u4f73\u5316\u63aa\u65bd\uff0c\u4ee5\u5927\u5e45\u63d0\u5347\u6aa2\u67e5\u9ede\u5132\u5b58\u548c\u8f09\u5165\u7684\u6548\u7387\u3002\u5be6\u9a57\u7d50\u679c\u8b49\u660e\uff0c\u8207\u57fa\u7dda\u65b9\u6cd5\u76f8\u6bd4\uff0cByteCheckpoint \u5728\u6e1b\u5c11\u6aa2\u67e5\u9ede\u5132\u5b58 (\u6700\u591a\u6e1b\u5c11 529.22 \u500d) \u548c\u8f09\u5165 (\u6700\u591a\u6e1b\u5c11 3.51 \u500d) \u6210\u672c\u65b9\u9762\u5177\u6709\u986f\u8457\u512a\u52e2\u3002</paragraph>", "author": "Borui Wan et.al.", "authors": "Borui Wan, Mingji Han, Yiyao Sheng, Zhichao Lai, Mofan Zhang, Junda Zhang, Yanghua Peng, Haibin Lin, Xin Liu, Chuan Wu", "id": "2407.20143v1", "paper_url": "http://arxiv.org/abs/2407.20143v1", "repo": "null"}}